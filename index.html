<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Demo</title>
  <link rel="stylesheet" href="stylesheets/main.css">
</head>
<body>

  <p>What would the advantages of a DOM-based game?</p>

  <ol>
    <li>Animations would be easy to implement without requiring
      an always-running update loop.</li>
    <li>Could animate cards either returning to their original location, or snapping into place</li>
    <li>Could animate cards flipping in 3d space</li>
    <li>Could create an animation for dropping cards on a foundation</li>
  </ol>

  <p>disadvantages</p>

  <ol>
    <li>implementing card waterfall would be a PITA -- would have to overlay a canvas and import images
      from the DOM -- would have to use &lt;img> tags for card fronts/backs (https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)</li>
    <li>alternative idea: background is a &lt;canvas>, and every update draws the card image at its current position</li>
  </ol>

  <p>how would we handle displaying card cascades? would need to recursively move child cards</p>


  <p>how would piles, foundations, etc. work in this version of the game?
    I'm imagining that since I want to attach event listeners to each card, the card itself would need to know
    what stack it's in. Otherwise we'd need to have an invisible "stack" object that would layer itself on top
    of all its contents.
  </p>

  <!-- https://tobiasahlin.com/blog/how-to-animate-box-shadow/ -->

  <style type="text/css">

  </style>

  <script src="scripts/card.js"></script>
  <script src="scripts/stack.js"></script>
  <script src="scripts/grabbed.js"></script>
  <script src="scripts/cell.js"></script>
  <script src="scripts/cascade.js"></script>
  <script src="scripts/foundation.js"></script>

  <script>
    const wait = ms => {
      return new Promise(resolve => {
        setTimeout(resolve, ms);
      });
    };

    const SUITS = ['hearts', 'spades', 'diamonds', 'clubs'];
    const RANKS = ['ace', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'jack', 'queen', 'king'];

    // used for custom double-click/tap implementation
    // this val is set in `onDown` function; if it is called again rapidly
    // (e.g. within 500ms) then the interaction counts as a double-click
    let lastOnDownTimestamp = Date.now();

    const cascades = [];
    for (let i = 0; i < 8; i += 1) {
      const cascade = new Cascade();
      cascade.moveTo(10 + (85 * i), 100);
      cascades.push(cascade);

      // these don't have a visible component,
      // so we don't need to append them to the DOM
    }

    const foundations = [];
    for (let i = 0; i < 4; i += 1) {
      const foundation = new Foundation();
      foundation.moveTo(10 + (85 * i), 10);
      foundations.push(foundation);

      // Make these visible by adding to DOM
      document.body.append(foundation.element);
    }

    const cells = [];
    for (let i = 4; i < 8; i += 1) {
      const cell = new Cell();
      cell.moveTo(10 + (85 * i), 10);
      cells.push(cell);

      // Make these visible by adding to DOM
      document.body.append(cell.element);
    }

    let grabbed = new Grabbed();

    const deck = [];
    const cards = [];

    // initialize list of cards
    SUITS.forEach(suit => {
      RANKS.forEach(rank => {
        const card = new Card(suit, rank);
        document.body.append(card.element);

        // move all cards to an arbitrary point in the center
        // of the tableau, so we can get a "dealing" animation
        card.moveTo(500, 500);

        deck.push(card);
        cards.push(card);
      });
    });

    const attemptToPlayOnFoundation = card => {
      for (let i = 0; i < foundations.length; i += 1) {
        const foundation = foundations[i];

        if (foundation.validPlay(card)) {
          const parent = foundation.lastCard;
          card.setParent(parent);
          card.animateTo(parent.x, parent.y);

          // if we have a valid play, return from this function;
          // no need to look further
          break;
        }
      }

      // TODO: check win condition here
    };

    deck.forEach(card => {
      card.element.addEventListener('mousedown', e => {
        e.preventDefault();

        const delta = Date.now() - lastOnDownTimestamp;
        const doubleClick = delta < 500;

        // reset the timestamp that stores the last time the player clicked
        // if the current click counts as "double", then set the timestamp way in the past
        // otherwise you get a "3 click double click" because the 2nd/3rd clicks are too close together
        lastOnDownTimestamp = doubleClick ? 0 : Date.now();

        if (doubleClick) {
          console.log(`double click! attempt to play ${card} on foundations`);
          attemptToPlayOnFoundation(card);
          return;
        }

        // only allow alternating sequences of cards to be picked up
        if (!card.childrenInSequence) {
          console.log(`can't pick up ${card}, not a sequence!`);
          return;
        }

        // this gets global click position
        const { x, y } =  e;

        grabbed.grab(card);
        grabbed.setOffset({x, y});

        console.log(`mousedown on ${card}`);
      });
    });

    document.body.addEventListener('mousemove', e => {
      e.preventDefault();

      if (!grabbed.hasCards) {
        return;
      }

      // this gets global click position
      const { x, y } =  e;

      grabbed.moveTo({x, y});
    });

    document.body.addEventListener('mouseup', e => {
      e.preventDefault();

      if (!grabbed.hasCards) {
        return;
      }

      let valid = false;
      const card = grabbed.child;

      // check foundations
      for (let i = 0; i < foundations.length; i += 1) {
        const foundation = foundations[i];

        // only allow placement in foundation if a valid play, and
        // player is holding a single card
        if (grabbed.overlaps(foundation) && foundation.validPlay(card) && !card.child) {
          valid = true;

          console.log(`dropping ${card} on foundation #${i}`);

          card.setParent(foundation);
          card.animateTo(foundation.x, foundation.y);

          // valid play, so break out of the loop checking other foundations
          break;
        }
      }

      // check cells
      for (let i = 0; i < cells.length; i += 1) {
        const cell = cells[i];

        // only allow placemnt in a cell if the cell is empty and
        // player is holding a single card
        if (grabbed.overlaps(cell) && !cell.hasCards && !card.child) {
          valid = true;

          console.log(`dropping ${card} on cell #${i}`);

          grabbed.drop(cell);

          // valid play, so break out of the loop checking other cells
          break;
        }
      }

      // check cascades
      for (let i = 0; i < cascades.length; i += 1) {
        const cascade = cascades[i];

        if (grabbed.overlaps(cascade) && cascade.validPlay(card)) {
          valid = true;

          console.log(`dropping ${card} on cascade #${i}`);

          grabbed.drop(cascade.lastCard);

          // valid play, so break out of the loop checking other cells
          break;
        }
      }

      // if we got this far, that means no valid move was made,
      // so the card(s) can go back to their original position
      if (!valid) {
        console.log('invalid move; dropping card(s) on original position');
        grabbed.drop();
      }

      // TODO: add this to `grabbed.drop`
      grabbed.child = null;
    });

    const onResize = () => {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const aspectRatio = 4 / 3;
      const scale = window.devicePixelRatio;

      // playable area, where cards will be drawn
      let tableauWidth;
      let tableauHeight;

      if (windowWidth / windowHeight > aspectRatio) {
        // wider than it is tall; use the window height to calculate tableau width
        tableauWidth = windowHeight * aspectRatio;
        tableauHeight = windowHeight;
      } else {
        // taller than it is wide; use window width to calculate tableau height
        tableauHeight = windowWidth / aspectRatio;
        tableauWidth = windowWidth;
      }

      let windowMargin = (windowWidth - tableauWidth) / 2;

      // tweak these values as necessary
      let cardMargin = (5 / 605) * tableauWidth;

      // cards _should_ be 75x100
      let cardWidth = (70 / 605) * tableauWidth;
      let cardHeight = (93.333 / 454) * tableauHeight;
      let cardOffset = cardHeight / 4; // e.g. 25px

      // enumerate over all cards/stacks in order to set their width/height
      for (let group of [grabbed, cells, foundations, cascades, cards]) {
        if (Array.isArray(group)) {
          // if (group[0].type === 'foundation') {
          //   debugger;
          // }
          for (let item of group) {
            item.size = {
              width: cardWidth,
              height: cardHeight
            };

            item.offset = cardOffset;
          }
        } else {
          group.size = {
            width: cardWidth,
            height: cardHeight
          };

          group.offset = cardOffset;
        }
      }

      const top = cardMargin;
      const left = windowMargin + cardMargin;

      // foundations on the left
      foundations.forEach((f, i) => {
        f.moveTo(left + (cardWidth + cardMargin) * i, top);
      });

      // cells are on the right; the (i + 4) allows space for foundations
      cells.forEach((c, i) => {
        c.moveTo(left + (cardWidth + cardMargin) * (i + 4), top)
      });

      cascades.forEach((c, i) => {
         // allows space for cells/foundation
        c.moveTo(windowMargin + cardMargin + (cardWidth + cardMargin) * i, top + cardHeight + cardMargin)
      });
    };

    window.addEventListener('resize', onResize);

    // initial resize
    onResize();

    // shuffle deck
    let currentIndex = deck.length;
    let randomIndex;

    // While there remain elements to shuffle.
    while (currentIndex !== 0) {
      // Pick a remaining element.
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;

      // And swap it with the current element.
      [deck[currentIndex], deck[randomIndex]] = [deck[randomIndex], deck[currentIndex]];
    }

    // deal cards
    let delay = 0;
    let offset = 0;
    let index = 0;
    while (deck.length) {
      const card = deck.pop();
      const cascade = cascades[index % cascades.length];
      const lastCard = cascade.lastCard;

      card.setParent(lastCard);

      ((card, lastCard, offset, delay) => {
        wait(delay).then(() => card.animateTo(lastCard.x, lastCard.y + offset));
      })(card, lastCard, offset, delay);

      delay += 10; // 50ms looks nice
      offset = index < 7 ? 0 : card.offset;
      index += 1;
    }
  </script>

  <!--
    css box-shadow examples:

    box-shadow: rgba(240, 46, 170, 0.4) 0px 5px,
rgba(240, 46, 170, 0.3) 0px 10px,
rgba(240, 46, 170, 0.2) 0px 15px,
rgba(240, 46, 170, 0.1) 0px 20px,
rgba(240, 46, 170, 0.05) 0px 25px;



box-shadow: rgb(85, 91, 255) 0px 0px 0px 3px,
rgb(31, 193, 27) 0px 0px 0px 6px,
rgb(255, 217, 19) 0px 0px 0px 9px,
rgb(255, 156, 85) 0px 0px 0px 12px,
rgb(255, 85, 85) 0px 0px 0px 15px;


box-shadow: rgba(3, 102, 214, 0.3) 0px 0px 0px 3px;

   -->
</body>
</html>
